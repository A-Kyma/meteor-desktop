"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _runtime = _interopRequireDefault(require("regenerator-runtime/runtime"));

var _lodash = require("lodash");

var _log = _interopRequireDefault(require("./log"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-unused-vars

/**
 * Utility class designed for merging dependencies list with simple validation and duplicate
 * detection.
 *
 * @class
 */
class DependenciesManager {
  /**
   * @param {MeteorDesktop} $                   - context
   * @param {Object}        defaultDependencies - core dependencies list
   * @constructor
   */
  constructor($, defaultDependencies) {
    this.log = new _log.default('dependenciesManager');
    this.$ = $;
    this.dependencies = defaultDependencies; // Regexes for matching certain types of dependencies version.
    // https://docs.npmjs.com/files/package.json#dependencies

    this.regexes = {
      local: /^(\.\.\/|~\/|\.\/|\/)/,
      git: /^git(\+(ssh|http)s?)?/,
      github: /^\w+-?\w+(?!-)\//,
      http: /^https?.+tar\.gz/,
      file: /^file:/
    }; // Check for commit hashes.

    const gitCheck = {
      type: 'regex',
      regex: /#[a-f0-9]{7,40}/,
      test: 'match',
      message: 'git or github link must have a commit hash'
    }; // Check for displaying warnings when npm package from local path is used.

    const localCheck = {
      onceName: 'localCheck',
      type: 'warning',
      message: 'using dependencies from local paths is permitted' + ' but dangerous - read more in README.md'
    };
    this.checks = {
      local: localCheck,
      file: localCheck,
      git: gitCheck,
      github: gitCheck,
      version: {
        type: 'regex',
        // Matches all the semver ranges operators, empty strings and `*`.
        regex: /[\^|><= ~-]|\.x|^$|^\*$/,
        test: 'do not match',
        message: 'semver ranges are forbidden, please specify exact version'
      }
    };
  }
  /**
   * Just a public getter.
   * @returns {Object}
   */


  getDependencies() {
    return this.dependencies;
  }
  /**
   * Returns local dependencies.
   * @returns {Object}
   */


  getLocalDependencies() {
    return Object.keys(this.dependencies).filter(dependency => this.regexes.local.test(this.dependencies[dependency]) || this.regexes.file.test(this.dependencies[dependency])).reduce((localDependencies, currentDependency) => Object.assign(localDependencies, {
      [currentDependency]: this.dependencies[currentDependency]
    }), {});
  }
  /**
   * Returns remote dependencies.
   * @returns {Object}
   */


  getRemoteDependencies() {
    return Object.keys(this.dependencies).filter(dependency => !this.regexes.local.test(this.dependencies[dependency]) && !this.regexes.file.test(this.dependencies[dependency])).reduce((localDependencies, currentDependency) => Object.assign(localDependencies, {
      [currentDependency]: this.dependencies[currentDependency]
    }), {});
  }
  /**
   * Merges dependencies into one list.
   *
   * @param {string} from         - describes where the dependencies were set
   * @param {Object} dependencies - dependencies list
   */


  mergeDependencies(from, dependencies) {
    if (this.validateDependenciesVersions(from, dependencies)) {
      this.detectDuplicatedDependencies(from, dependencies);
      (0, _lodash.assignIn)(this.dependencies, dependencies);
    }
  }
  /**
   * Detects dependency version type.
   * @param {string} version - version string of the dependency
   * @return {string}
   */


  detectDependencyVersionType(version) {
    const type = Object.keys(this.regexes).find(dependencyType => this.regexes[dependencyType].test(version));
    return type || 'version';
  }
  /**
   * Validates semver and detect ranges.
   *
   * @param {string} from         - describes where the dependencies were set
   * @param {Object} dependencies - dependencies list
   */


  validateDependenciesVersions(from, dependencies) {
    const warningsShown = {};
    (0, _lodash.forEach)(dependencies, (version, name) => {
      const type = this.detectDependencyVersionType(version);

      if (this.checks[type]) {
        const check = this.checks[type];

        if (check.type === 'regex') {
          const checkResult = check.test === 'match' ? this.checks[type].regex.test(version) : !this.checks[type].regex.test(version);

          if (!checkResult) {
            throw new Error(`dependency ${name}:${version} from ${from} failed version ` + `check with message: ${this.checks[type].message}`);
          }
        }

        if (check.type === 'warning' && !warningsShown[check.onceName]) {
          warningsShown[check.onceName] = true;
          this.log.warn(`dependency ${name}:${version} from ${from} caused a` + ` warning: ${check.message}`);
        }
      }
    });
    return true;
  }
  /**
   * Detects duplicates.
   *
   * @param {string} from         - describes where the dependencies were set
   * @param {Object} dependencies - dependencies list
   */


  detectDuplicatedDependencies(from, dependencies) {
    const duplicates = (0, _lodash.intersection)(Object.keys(dependencies), Object.keys(this.dependencies));

    if (duplicates.length > 0) {
      duplicates.forEach(name => {
        if (dependencies[name] !== this.dependencies[name]) {
          throw new Error(`While processing dependencies from ${from}, a dependency ` + `${name}: ${dependencies[name]} was found to be conflicting with a ` + `dependency (${this.dependencies[name]}) that was already declared in ` + 'other module or it is used in core of the electron app.');
        }
      });
    }
  }

}

exports.default = DependenciesManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEZXBlbmRlbmNpZXNNYW5hZ2VyIiwiY29uc3RydWN0b3IiLCIkIiwiZGVmYXVsdERlcGVuZGVuY2llcyIsImxvZyIsIkxvZyIsImRlcGVuZGVuY2llcyIsInJlZ2V4ZXMiLCJsb2NhbCIsImdpdCIsImdpdGh1YiIsImh0dHAiLCJmaWxlIiwiZ2l0Q2hlY2siLCJ0eXBlIiwicmVnZXgiLCJ0ZXN0IiwibWVzc2FnZSIsImxvY2FsQ2hlY2siLCJvbmNlTmFtZSIsImNoZWNrcyIsInZlcnNpb24iLCJnZXREZXBlbmRlbmNpZXMiLCJnZXRMb2NhbERlcGVuZGVuY2llcyIsIk9iamVjdCIsImtleXMiLCJmaWx0ZXIiLCJkZXBlbmRlbmN5IiwicmVkdWNlIiwibG9jYWxEZXBlbmRlbmNpZXMiLCJjdXJyZW50RGVwZW5kZW5jeSIsImFzc2lnbiIsImdldFJlbW90ZURlcGVuZGVuY2llcyIsIm1lcmdlRGVwZW5kZW5jaWVzIiwiZnJvbSIsInZhbGlkYXRlRGVwZW5kZW5jaWVzVmVyc2lvbnMiLCJkZXRlY3REdXBsaWNhdGVkRGVwZW5kZW5jaWVzIiwiYXNzaWduSW4iLCJkZXRlY3REZXBlbmRlbmN5VmVyc2lvblR5cGUiLCJmaW5kIiwiZGVwZW5kZW5jeVR5cGUiLCJ3YXJuaW5nc1Nob3duIiwiZm9yRWFjaCIsIm5hbWUiLCJjaGVjayIsImNoZWNrUmVzdWx0IiwiRXJyb3IiLCJ3YXJuIiwiZHVwbGljYXRlcyIsImludGVyc2VjdGlvbiIsImxlbmd0aCJdLCJzb3VyY2VzIjpbIi4uL2xpYi9kZXBlbmRlbmNpZXNNYW5hZ2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IHJlZ2VuZXJhdG9yUnVudGltZSBmcm9tICdyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUnO1xuaW1wb3J0IHsgZm9yRWFjaCwgYXNzaWduSW4sIGludGVyc2VjdGlvbiB9IGZyb20gJ2xvZGFzaCc7XG5cbmltcG9ydCBMb2cgZnJvbSAnLi9sb2cnO1xuXG4vKipcbiAqIFV0aWxpdHkgY2xhc3MgZGVzaWduZWQgZm9yIG1lcmdpbmcgZGVwZW5kZW5jaWVzIGxpc3Qgd2l0aCBzaW1wbGUgdmFsaWRhdGlvbiBhbmQgZHVwbGljYXRlXG4gKiBkZXRlY3Rpb24uXG4gKlxuICogQGNsYXNzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlcGVuZGVuY2llc01hbmFnZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TWV0ZW9yRGVza3RvcH0gJCAgICAgICAgICAgICAgICAgICAtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIGRlZmF1bHREZXBlbmRlbmNpZXMgLSBjb3JlIGRlcGVuZGVuY2llcyBsaXN0XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoJCwgZGVmYXVsdERlcGVuZGVuY2llcykge1xuICAgICAgICB0aGlzLmxvZyA9IG5ldyBMb2coJ2RlcGVuZGVuY2llc01hbmFnZXInKTtcbiAgICAgICAgdGhpcy4kID0gJDtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZWZhdWx0RGVwZW5kZW5jaWVzO1xuXG4gICAgICAgIC8vIFJlZ2V4ZXMgZm9yIG1hdGNoaW5nIGNlcnRhaW4gdHlwZXMgb2YgZGVwZW5kZW5jaWVzIHZlcnNpb24uXG4gICAgICAgIC8vIGh0dHBzOi8vZG9jcy5ucG1qcy5jb20vZmlsZXMvcGFja2FnZS5qc29uI2RlcGVuZGVuY2llc1xuICAgICAgICB0aGlzLnJlZ2V4ZXMgPSB7XG4gICAgICAgICAgICBsb2NhbDogL14oXFwuXFwuXFwvfH5cXC98XFwuXFwvfFxcLykvLFxuICAgICAgICAgICAgZ2l0OiAvXmdpdChcXCsoc3NofGh0dHApcz8pPy8sXG4gICAgICAgICAgICBnaXRodWI6IC9eXFx3Ky0/XFx3Kyg/IS0pXFwvLyxcbiAgICAgICAgICAgIGh0dHA6IC9eaHR0cHM/Lit0YXJcXC5nei8sXG4gICAgICAgICAgICBmaWxlOiAvXmZpbGU6L1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBjb21taXQgaGFzaGVzLlxuICAgICAgICBjb25zdCBnaXRDaGVjayA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdyZWdleCcsXG4gICAgICAgICAgICByZWdleDogLyNbYS1mMC05XXs3LDQwfS8sXG4gICAgICAgICAgICB0ZXN0OiAnbWF0Y2gnLFxuICAgICAgICAgICAgbWVzc2FnZTogJ2dpdCBvciBnaXRodWIgbGluayBtdXN0IGhhdmUgYSBjb21taXQgaGFzaCdcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDaGVjayBmb3IgZGlzcGxheWluZyB3YXJuaW5ncyB3aGVuIG5wbSBwYWNrYWdlIGZyb20gbG9jYWwgcGF0aCBpcyB1c2VkLlxuICAgICAgICBjb25zdCBsb2NhbENoZWNrID0ge1xuICAgICAgICAgICAgb25jZU5hbWU6ICdsb2NhbENoZWNrJyxcbiAgICAgICAgICAgIHR5cGU6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICd1c2luZyBkZXBlbmRlbmNpZXMgZnJvbSBsb2NhbCBwYXRocyBpcyBwZXJtaXR0ZWQnICtcbiAgICAgICAgICAgICcgYnV0IGRhbmdlcm91cyAtIHJlYWQgbW9yZSBpbiBSRUFETUUubWQnXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jaGVja3MgPSB7XG4gICAgICAgICAgICBsb2NhbDogbG9jYWxDaGVjayxcbiAgICAgICAgICAgIGZpbGU6IGxvY2FsQ2hlY2ssXG4gICAgICAgICAgICBnaXQ6IGdpdENoZWNrLFxuICAgICAgICAgICAgZ2l0aHViOiBnaXRDaGVjayxcbiAgICAgICAgICAgIHZlcnNpb246IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncmVnZXgnLFxuICAgICAgICAgICAgICAgIC8vIE1hdGNoZXMgYWxsIHRoZSBzZW12ZXIgcmFuZ2VzIG9wZXJhdG9ycywgZW1wdHkgc3RyaW5ncyBhbmQgYCpgLlxuICAgICAgICAgICAgICAgIHJlZ2V4OiAvW1xcXnw+PD0gfi1dfFxcLnh8XiR8XlxcKiQvLFxuICAgICAgICAgICAgICAgIHRlc3Q6ICdkbyBub3QgbWF0Y2gnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdzZW12ZXIgcmFuZ2VzIGFyZSBmb3JiaWRkZW4sIHBsZWFzZSBzcGVjaWZ5IGV4YWN0IHZlcnNpb24nXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSnVzdCBhIHB1YmxpYyBnZXR0ZXIuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXREZXBlbmRlbmNpZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcGVuZGVuY2llcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxvY2FsIGRlcGVuZGVuY2llcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldExvY2FsRGVwZW5kZW5jaWVzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0XG4gICAgICAgICAgICAua2V5cyh0aGlzLmRlcGVuZGVuY2llcylcbiAgICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeSA9PlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2V4ZXMubG9jYWwudGVzdCh0aGlzLmRlcGVuZGVuY2llc1tkZXBlbmRlbmN5XSkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWdleGVzLmZpbGUudGVzdCh0aGlzLmRlcGVuZGVuY2llc1tkZXBlbmRlbmN5XSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5yZWR1Y2UoXG4gICAgICAgICAgICAgICAgKGxvY2FsRGVwZW5kZW5jaWVzLCBjdXJyZW50RGVwZW5kZW5jeSkgPT5cbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsRGVwZW5kZW5jaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBbY3VycmVudERlcGVuZGVuY3ldOiB0aGlzLmRlcGVuZGVuY2llc1tjdXJyZW50RGVwZW5kZW5jeV0gfVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHt9XG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmVtb3RlIGRlcGVuZGVuY2llcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFJlbW90ZURlcGVuZGVuY2llcygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdFxuICAgICAgICAgICAgLmtleXModGhpcy5kZXBlbmRlbmNpZXMpXG4gICAgICAgICAgICAuZmlsdGVyKFxuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kgPT5cbiAgICAgICAgICAgICAgICAgICAgIXRoaXMucmVnZXhlcy5sb2NhbC50ZXN0KHRoaXMuZGVwZW5kZW5jaWVzW2RlcGVuZGVuY3ldKSAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5yZWdleGVzLmZpbGUudGVzdCh0aGlzLmRlcGVuZGVuY2llc1tkZXBlbmRlbmN5XSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5yZWR1Y2UoXG4gICAgICAgICAgICAgICAgKGxvY2FsRGVwZW5kZW5jaWVzLCBjdXJyZW50RGVwZW5kZW5jeSkgPT5cbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsRGVwZW5kZW5jaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBbY3VycmVudERlcGVuZGVuY3ldOiB0aGlzLmRlcGVuZGVuY2llc1tjdXJyZW50RGVwZW5kZW5jeV0gfVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHt9XG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBkZXBlbmRlbmNpZXMgaW50byBvbmUgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tICAgICAgICAgLSBkZXNjcmliZXMgd2hlcmUgdGhlIGRlcGVuZGVuY2llcyB3ZXJlIHNldFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZXBlbmRlbmNpZXMgLSBkZXBlbmRlbmNpZXMgbGlzdFxuICAgICAqL1xuICAgIG1lcmdlRGVwZW5kZW5jaWVzKGZyb20sIGRlcGVuZGVuY2llcykge1xuICAgICAgICBpZiAodGhpcy52YWxpZGF0ZURlcGVuZGVuY2llc1ZlcnNpb25zKGZyb20sIGRlcGVuZGVuY2llcykpIHtcbiAgICAgICAgICAgIHRoaXMuZGV0ZWN0RHVwbGljYXRlZERlcGVuZGVuY2llcyhmcm9tLCBkZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgYXNzaWduSW4odGhpcy5kZXBlbmRlbmNpZXMsIGRlcGVuZGVuY2llcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3RzIGRlcGVuZGVuY3kgdmVyc2lvbiB0eXBlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJzaW9uIC0gdmVyc2lvbiBzdHJpbmcgb2YgdGhlIGRlcGVuZGVuY3lcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZGV0ZWN0RGVwZW5kZW5jeVZlcnNpb25UeXBlKHZlcnNpb24pIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IE9iamVjdC5rZXlzKHRoaXMucmVnZXhlcylcbiAgICAgICAgICAgIC5maW5kKGRlcGVuZGVuY3lUeXBlID0+IHRoaXMucmVnZXhlc1tkZXBlbmRlbmN5VHlwZV0udGVzdCh2ZXJzaW9uKSk7XG4gICAgICAgIHJldHVybiB0eXBlIHx8ICd2ZXJzaW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgc2VtdmVyIGFuZCBkZXRlY3QgcmFuZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZyb20gICAgICAgICAtIGRlc2NyaWJlcyB3aGVyZSB0aGUgZGVwZW5kZW5jaWVzIHdlcmUgc2V0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlcGVuZGVuY2llcyAtIGRlcGVuZGVuY2llcyBsaXN0XG4gICAgICovXG4gICAgdmFsaWRhdGVEZXBlbmRlbmNpZXNWZXJzaW9ucyhmcm9tLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgY29uc3Qgd2FybmluZ3NTaG93biA9IHt9O1xuICAgICAgICBmb3JFYWNoKGRlcGVuZGVuY2llcywgKHZlcnNpb24sIG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmRldGVjdERlcGVuZGVuY3lWZXJzaW9uVHlwZSh2ZXJzaW9uKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gdGhpcy5jaGVja3NbdHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrLnR5cGUgPT09ICdyZWdleCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hlY2tSZXN1bHQgPSBjaGVjay50ZXN0ID09PSAnbWF0Y2gnID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tzW3R5cGVdLnJlZ2V4LnRlc3QodmVyc2lvbikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuY2hlY2tzW3R5cGVdLnJlZ2V4LnRlc3QodmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGVwZW5kZW5jeSAke25hbWV9OiR7dmVyc2lvbn0gZnJvbSAke2Zyb219IGZhaWxlZCB2ZXJzaW9uIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBjaGVjayB3aXRoIG1lc3NhZ2U6ICR7dGhpcy5jaGVja3NbdHlwZV0ubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hlY2sudHlwZSA9PT0gJ3dhcm5pbmcnICYmICF3YXJuaW5nc1Nob3duW2NoZWNrLm9uY2VOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nc1Nob3duW2NoZWNrLm9uY2VOYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLndhcm4oYGRlcGVuZGVuY3kgJHtuYW1lfToke3ZlcnNpb259IGZyb20gJHtmcm9tfSBjYXVzZWQgYWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCB3YXJuaW5nOiAke2NoZWNrLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0cyBkdXBsaWNhdGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZyb20gICAgICAgICAtIGRlc2NyaWJlcyB3aGVyZSB0aGUgZGVwZW5kZW5jaWVzIHdlcmUgc2V0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlcGVuZGVuY2llcyAtIGRlcGVuZGVuY2llcyBsaXN0XG4gICAgICovXG4gICAgZGV0ZWN0RHVwbGljYXRlZERlcGVuZGVuY2llcyhmcm9tLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgY29uc3QgZHVwbGljYXRlcyA9IGludGVyc2VjdGlvbihPYmplY3Qua2V5cyhkZXBlbmRlbmNpZXMpLCBPYmplY3Qua2V5cyh0aGlzLmRlcGVuZGVuY2llcykpO1xuICAgICAgICBpZiAoZHVwbGljYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkdXBsaWNhdGVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGVwZW5kZW5jaWVzW25hbWVdICE9PSB0aGlzLmRlcGVuZGVuY2llc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdoaWxlIHByb2Nlc3NpbmcgZGVwZW5kZW5jaWVzIGZyb20gJHtmcm9tfSwgYSBkZXBlbmRlbmN5IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCR7bmFtZX06ICR7ZGVwZW5kZW5jaWVzW25hbWVdfSB3YXMgZm91bmQgdG8gYmUgY29uZmxpY3Rpbmcgd2l0aCBhIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGRlcGVuZGVuY3kgKCR7dGhpcy5kZXBlbmRlbmNpZXNbbmFtZV19KSB0aGF0IHdhcyBhbHJlYWR5IGRlY2xhcmVkIGluIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ290aGVyIG1vZHVsZSBvciBpdCBpcyB1c2VkIGluIGNvcmUgb2YgdGhlIGVsZWN0cm9uIGFwcC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNBOztBQUNBOztBQUVBOzs7O0FBSkE7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsTUFBTUEsbUJBQU4sQ0FBMEI7RUFDckM7QUFDSjtBQUNBO0FBQ0E7QUFDQTtFQUNJQyxXQUFXLENBQUNDLENBQUQsRUFBSUMsbUJBQUosRUFBeUI7SUFDaEMsS0FBS0MsR0FBTCxHQUFXLElBQUlDLFlBQUosQ0FBUSxxQkFBUixDQUFYO0lBQ0EsS0FBS0gsQ0FBTCxHQUFTQSxDQUFUO0lBQ0EsS0FBS0ksWUFBTCxHQUFvQkgsbUJBQXBCLENBSGdDLENBS2hDO0lBQ0E7O0lBQ0EsS0FBS0ksT0FBTCxHQUFlO01BQ1hDLEtBQUssRUFBRSx1QkFESTtNQUVYQyxHQUFHLEVBQUUsdUJBRk07TUFHWEMsTUFBTSxFQUFFLGtCQUhHO01BSVhDLElBQUksRUFBRSxrQkFKSztNQUtYQyxJQUFJLEVBQUU7SUFMSyxDQUFmLENBUGdDLENBZWhDOztJQUNBLE1BQU1DLFFBQVEsR0FBRztNQUNiQyxJQUFJ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