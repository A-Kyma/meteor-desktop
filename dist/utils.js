"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.computeHashForHashesSet = computeHashForHashesSet;
exports.default = void 0;
exports.exists = exists;
exports.getFileList = getFileList;
exports.readAndGetFileHash = readAndGetFileHash;
exports.readAndHashFiles = readAndHashFiles;
exports.readDir = readDir;
exports.readFilesAndComputeHash = readFilesAndComputeHash;
exports.rmWithRetries = rmWithRetries;
exports.symlinkExists = symlinkExists;

var _path = _interopRequireDefault(require("path"));

var _fs = _interopRequireDefault(require("fs"));

var _crypto = _interopRequireDefault(require("crypto"));

var _shelljs = _interopRequireDefault(require("shelljs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable consistent-return */

/**
 * Exists
 * @param {string} pathToCheck
 * @returns {boolean}
 */
function exists(pathToCheck) {
  try {
    _fs.default.accessSync(pathToCheck);

    return true;
  } catch (e) {
    return false;
  }
}
/**
 * Simple wrapper for shelljs.rm with additional retries in case of failure.
 * It is useful when something is concurrently reading the dir you want to remove.
 */


function rmWithRetries(...args) {
  let retries = 0;
  return new Promise((resolve, reject) => {
    function rm(...rmArgs) {
      try {
        _shelljs.default.config.fatal = true;

        _shelljs.default.rm(...rmArgs);

        _shelljs.default.config.reset();

        resolve();
      } catch (e) {
        retries += 1;

        if (retries < 5) {
          setTimeout(() => {
            rm(...rmArgs);
          }, 100);
        } else {
          _shelljs.default.config.reset();

          reject(e);
        }
      }
    }

    rm(...args);
  });
}

function readDir(dir, callback) {
  if (!callback) {
    return new Promise((resolve, reject) => {
      readDir(dir, (err, data, stats) => {
        if (err) {
          reject(err);
        } else {
          resolve({
            data,
            stats
          });
        }
      });
    });
  }

  let list = [];
  let allStats = {};

  _fs.default.readdir(dir, (err, files) => {
    if (err) {
      return callback(err);
    }

    let pending = files.length;

    if (!pending) {
      return callback(null, list, allStats);
    }

    files.forEach(file => {
      const filePath = _path.default.join(dir, file);

      _fs.default.stat(filePath, (_err, stats) => {
        if (_err) {
          return callback(_err);
        }

        if (stats.isDirectory()) {
          readDir(filePath, (__err, res, _allStats) => {
            if (__err) {
              return callback(__err);
            }

            list = list.concat(res);
            allStats = Object.assign(allStats, _allStats);
            pending -= 1;

            if (!pending) {
              return callback(null, list, allStats);
            }
          });
        } else {
          list.push(filePath);
          allStats[filePath] = {
            size: stats.size,
            dates: [stats.birthtime.getTime(), stats.ctime.getTime(), stats.mtime.getTime()]
          };
          pending -= 1;

          if (!pending) {
            return callback(null, list, allStats);
          }
        }
      });
    });
  });
}
/**
 * Returns a file list from a directory.
 * @param {string} dir - dir path
 * @param {boolean} sort - whether to apply sort
 * @returns {Promise<Array>}
 */


function getFileList(dir, sort = false) {
  return new Promise((resolve, reject) => {
    readDir(dir, (error, files) => {
      if (error) {
        reject(error);
        return;
      } // eslint-disable-next-line no-param-reassign


      let resultantFilesList;

      if (sort) {
        const stripLength = dir.substr(0, 2) === './' ? dir.length - 1 : dir.length + 1;
        let pathsUnified = files.map(pth => pth.substr(stripLength).replace(/[\\/]/gm, '-'));
        const temporaryIndex = {};
        files.forEach((file, i) => {
          temporaryIndex[pathsUnified[i]] = file;
        });
        pathsUnified = pathsUnified.sort();
        const filesSorted = [];
        pathsUnified.forEach(key => {
          filesSorted.push(temporaryIndex[key]);
        });
        resultantFilesList = filesSorted;
      } else {
        resultantFilesList = files;
      }

      resolve(resultantFilesList);
    });
  });
}
/**
 * Returns file's hash.
 * @param {string} file - file path
 * @param {boolean} returnFileContents - include file contents in the resultant object
 * @returns {Promise<Object>}
 */


function readAndGetFileHash(file, returnFileContents = false) {
  return new Promise((resolve, reject) => {
    _fs.default.readFile(file, (err, data) => {
      if (err) {
        reject(err);
        return;
      }

      const hash = _crypto.default.createHash('sha1');

      hash.update(data);
      const returnObject = {
        hash: hash.digest('hex')
      };

      if (returnFileContents) {
        returnObject.contents = data.toString('utf8');
      }

      resolve(returnObject);
    });
  });
}
/**
 * Calculates a hash from objects values in specified order.
 * @param {Array} orderOfKeys
 * @param {Object} hashSet
 * @param {Function} keyFilter
 * @returns {string}
 */


function computeHashForHashesSet(orderOfKeys, hashSet, keyFilter = key => key) {
  const hash = _crypto.default.createHash('sha1');

  const hashesJoined = orderOfKeys.reduce( // eslint-disable-next-line no-param-reassign,no-return-assign
  (tmpHash, key) => (tmpHash += hashSet[keyFilter(key)], tmpHash), '');
  hash.update(hashesJoined);
  return hash.digest('hex');
}
/**
 * Reads files from disk and computes hashes for them.
 * @param {Array} files - array with file paths
 * @returns {Promise<Object>}
 */


function readAndHashFiles(files, fileFilter) {
  const fileHashes = {};
  const fileContents = {};
  const promises = [];

  function readSingleFile(file) {
    return new Promise((resolve, reject) => {
      readAndGetFileHash(file, file.endsWith('.js') && !file.endsWith('.test.js')).then(result => {
        let fileName = file;

        if (fileFilter) {
          fileName = fileFilter(fileName);
        }

        fileHashes[fileName] = result.hash;

        if (result.contents) {
          fileContents[fileName] = result.contents;
        }

        resolve();
      }).catch(reject);
    });
  }

  files.forEach(file => {
    promises.push(readSingleFile(file));
  });
  return new Promise((resolve, reject) => {
    Promise.all(promises).then(() => {
      resolve({
        files,
        fileContents,
        fileHashes
      });
    }).catch(reject);
  });
}
/**
 * Reads files from .desktop and computes a version hash.
 *
 * @param {string} dir - path
 * @param {Function} fileFilter
 * @returns {Promise<Object>}
 */


function readFilesAndComputeHash(dir, fileFilter) {
  return new Promise((resolve, reject) => {
    getFileList(dir, true).catch(reject).then(files => readAndHashFiles(files, fileFilter)).catch(reject).then(result => {
      // eslint-disable-next-line no-param-reassign
      result.hash = computeHashForHashesSet(result.files, result.fileHashes, fileFilter);
      resolve(result);
    });
  });
}
/**
 * Symlink exists
 * @param {string} pathToCheck
 * @returns {boolean}
 */


function symlinkExists(pathToCheck) {
  try {
    _fs.default.readlinkSync(pathToCheck);

    return true;
  } catch (e) {
    return false;
  }
}

var _default = {
  getFileList,
  rmWithRetries,
  exists,
  readDir,
  readAndGetFileHash,
  computeHashForHashesSet,
  readAndHashFiles,
  readFilesAndComputeHash,
  symlinkExists
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJleGlzdHMiLCJwYXRoVG9DaGVjayIsImZzIiwiYWNjZXNzU3luYyIsImUiLCJybVdpdGhSZXRyaWVzIiwiYXJncyIsInJldHJpZXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJtIiwicm1BcmdzIiwic2hlbGwiLCJjb25maWciLCJmYXRhbCIsInJlc2V0Iiwic2V0VGltZW91dCIsInJlYWREaXIiLCJkaXIiLCJjYWxsYmFjayIsImVyciIsImRhdGEiLCJzdGF0cyIsImxpc3QiLCJhbGxTdGF0cyIsInJlYWRkaXIiLCJmaWxlcyIsInBlbmRpbmciLCJsZW5ndGgiLCJmb3JFYWNoIiwiZmlsZSIsImZpbGVQYXRoIiwicGF0aCIsImpvaW4iLCJzdGF0IiwiX2VyciIsImlzRGlyZWN0b3J5IiwiX19lcnIiLCJyZXMiLCJfYWxsU3RhdHMiLCJjb25jYXQiLCJPYmplY3QiLCJhc3NpZ24iLCJwdXNoIiwic2l6ZSIsImRhdGVzIiwiYmlydGh0aW1lIiwiZ2V0VGltZSIsImN0aW1lIiwibXRpbWUiLCJnZXRGaWxlTGlzdCIsInNvcnQiLCJlcnJvciIsInJlc3VsdGFudEZpbGVzTGlzdCIsInN0cmlwTGVuZ3RoIiwic3Vic3RyIiwicGF0aHNVbmlmaWVkIiwibWFwIiwicHRoIiwicmVwbGFjZSIsInRlbXBvcmFyeUluZGV4IiwiaSIsImZpbGVzU29ydGVkIiwia2V5IiwicmVhZEFuZEdldEZpbGVIYXNoIiwicmV0dXJuRmlsZUNvbnRlbnRzIiwicmVhZEZpbGUiLCJoYXNoIiwiY3J5cHRvIiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsInJldHVybk9iamVjdCIsImRpZ2VzdCIsImNvbnRlbnRzIiwidG9TdHJpbmciLCJjb21wdXRlSGFzaEZvckhhc2hlc1NldCIsIm9yZGVyT2ZLZXlzIiwiaGFzaFNldCIsImtleUZpbHRlciIsImhhc2hlc0pvaW5lZCIsInJlZHVjZSIsInRtcEhhc2giLCJyZWFkQW5kSGFzaEZpbGVzIiwiZmlsZUZpbHRlciIsImZpbGVIYXNoZXMiLCJmaWxlQ29udGVudHMiLCJwcm9taXNlcyIsInJlYWRTaW5nbGVGaWxlIiwiZW5kc1dpdGgiLCJ0aGVuIiwicmVzdWx0IiwiZmlsZU5hbWUiLCJjYXRjaCIsImFsbCIsInJlYWRGaWxlc0FuZENvbXB1dGVIYXNoIiwic3ltbGlua0V4aXN0cyIsInJlYWRsaW5rU3luYyJdLCJzb3VyY2VzIjpbIi4uL2xpYi91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHNoZWxsIGZyb20gJ3NoZWxsanMnO1xuXG4vKipcbiAqIEV4aXN0c1xuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhUb0NoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4aXN0cyhwYXRoVG9DaGVjaykge1xuICAgIHRyeSB7XG4gICAgICAgIGZzLmFjY2Vzc1N5bmMocGF0aFRvQ2hlY2spO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogU2ltcGxlIHdyYXBwZXIgZm9yIHNoZWxsanMucm0gd2l0aCBhZGRpdGlvbmFsIHJldHJpZXMgaW4gY2FzZSBvZiBmYWlsdXJlLlxuICogSXQgaXMgdXNlZnVsIHdoZW4gc29tZXRoaW5nIGlzIGNvbmN1cnJlbnRseSByZWFkaW5nIHRoZSBkaXIgeW91IHdhbnQgdG8gcmVtb3ZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcm1XaXRoUmV0cmllcyguLi5hcmdzKSB7XG4gICAgbGV0IHJldHJpZXMgPSAwO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIHJtKC4uLnJtQXJncykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzaGVsbC5jb25maWcuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNoZWxsLnJtKC4uLnJtQXJncyk7XG4gICAgICAgICAgICAgICAgc2hlbGwuY29uZmlnLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHJpZXMgKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAocmV0cmllcyA8IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBybSguLi5ybUFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNoZWxsLmNvbmZpZy5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJtKC4uLmFyZ3MpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVhZERpcihkaXIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVhZERpcihkaXIsIChlcnIsIGRhdGEsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgZGF0YSwgc3RhdHMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgbGlzdCA9IFtdO1xuICAgIGxldCBhbGxTdGF0cyA9IHt9O1xuXG4gICAgZnMucmVhZGRpcihkaXIsIChlcnIsIGZpbGVzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwZW5kaW5nID0gZmlsZXMubGVuZ3RoO1xuICAgICAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBsaXN0LCBhbGxTdGF0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4oZGlyLCBmaWxlKTtcbiAgICAgICAgICAgIGZzLnN0YXQoZmlsZVBhdGgsIChfZXJyLCBzdGF0cykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChfZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhfZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZERpcihmaWxlUGF0aCwgKF9fZXJyLCByZXMsIF9hbGxTdGF0cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9fZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKF9fZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QgPSBsaXN0LmNvbmNhdChyZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsU3RhdHMgPSBPYmplY3QuYXNzaWduKGFsbFN0YXRzLCBfYWxsU3RhdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGxpc3QsIGFsbFN0YXRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgYWxsU3RhdHNbZmlsZVBhdGhdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogc3RhdHMuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMuYmlydGh0aW1lLmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5jdGltZS5nZXRUaW1lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMubXRpbWUuZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbGlzdCwgYWxsU3RhdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmaWxlIGxpc3QgZnJvbSBhIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXIgLSBkaXIgcGF0aFxuICogQHBhcmFtIHtib29sZWFufSBzb3J0IC0gd2hldGhlciB0byBhcHBseSBzb3J0XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxlTGlzdChkaXIsIHNvcnQgPSBmYWxzZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHJlYWREaXIoZGlyLCAoZXJyb3IsIGZpbGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgbGV0IHJlc3VsdGFudEZpbGVzTGlzdDtcblxuICAgICAgICAgICAgaWYgKHNvcnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpcExlbmd0aCA9IChkaXIuc3Vic3RyKDAsIDIpID09PSAnLi8nKSA/IGRpci5sZW5ndGggLSAxIDogZGlyLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgbGV0IHBhdGhzVW5pZmllZCA9IGZpbGVzLm1hcCgocHRoID0+IHB0aC5zdWJzdHIoc3RyaXBMZW5ndGgpLnJlcGxhY2UoL1tcXFxcL10vZ20sICctJykpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wb3JhcnlJbmRleCA9IHt9O1xuICAgICAgICAgICAgICAgIGZpbGVzLmZvckVhY2goKGZpbGUsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcG9yYXJ5SW5kZXhbcGF0aHNVbmlmaWVkW2ldXSA9IGZpbGU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcGF0aHNVbmlmaWVkID0gcGF0aHNVbmlmaWVkLnNvcnQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlc1NvcnRlZCA9IFtdO1xuICAgICAgICAgICAgICAgIHBhdGhzVW5pZmllZC5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZXNTb3J0ZWQucHVzaCh0ZW1wb3JhcnlJbmRleFtrZXldKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXN1bHRhbnRGaWxlc0xpc3QgPSBmaWxlc1NvcnRlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0YW50RmlsZXNMaXN0ID0gZmlsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdGFudEZpbGVzTGlzdCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgZmlsZSdzIGhhc2guXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZSAtIGZpbGUgcGF0aFxuICogQHBhcmFtIHtib29sZWFufSByZXR1cm5GaWxlQ29udGVudHMgLSBpbmNsdWRlIGZpbGUgY29udGVudHMgaW4gdGhlIHJlc3VsdGFudCBvYmplY3RcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkQW5kR2V0RmlsZUhhc2goZmlsZSwgcmV0dXJuRmlsZUNvbnRlbnRzID0gZmFsc2UpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmcy5yZWFkRmlsZShmaWxlLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJyk7XG4gICAgICAgICAgICBoYXNoLnVwZGF0ZShkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHJldHVybk9iamVjdCA9IHsgaGFzaDogaGFzaC5kaWdlc3QoJ2hleCcpIH07XG4gICAgICAgICAgICBpZiAocmV0dXJuRmlsZUNvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuT2JqZWN0LmNvbnRlbnRzID0gZGF0YS50b1N0cmluZygndXRmOCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5PYmplY3QpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgaGFzaCBmcm9tIG9iamVjdHMgdmFsdWVzIGluIHNwZWNpZmllZCBvcmRlci5cbiAqIEBwYXJhbSB7QXJyYXl9IG9yZGVyT2ZLZXlzXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaFNldFxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5RmlsdGVyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhhc2hGb3JIYXNoZXNTZXQob3JkZXJPZktleXMsIGhhc2hTZXQsIGtleUZpbHRlciA9IGtleSA9PiBrZXkpIHtcbiAgICBjb25zdCBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKTtcbiAgICBjb25zdCBoYXNoZXNKb2luZWQgPSBvcmRlck9mS2V5cy5yZWR1Y2UoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbixuby1yZXR1cm4tYXNzaWduXG4gICAgICAgICh0bXBIYXNoLCBrZXkpID0+ICh0bXBIYXNoICs9IGhhc2hTZXRba2V5RmlsdGVyKGtleSldLCB0bXBIYXNoKSwgJydcbiAgICApO1xuICAgIGhhc2gudXBkYXRlKGhhc2hlc0pvaW5lZCk7XG4gICAgcmV0dXJuIGhhc2guZGlnZXN0KCdoZXgnKTtcbn1cblxuXG4vKipcbiAqIFJlYWRzIGZpbGVzIGZyb20gZGlzayBhbmQgY29tcHV0ZXMgaGFzaGVzIGZvciB0aGVtLlxuICogQHBhcmFtIHtBcnJheX0gZmlsZXMgLSBhcnJheSB3aXRoIGZpbGUgcGF0aHNcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkQW5kSGFzaEZpbGVzKGZpbGVzLCBmaWxlRmlsdGVyKSB7XG4gICAgY29uc3QgZmlsZUhhc2hlcyA9IHt9O1xuICAgIGNvbnN0IGZpbGVDb250ZW50cyA9IHt9O1xuICAgIGNvbnN0IHByb21pc2VzID0gW107XG5cbiAgICBmdW5jdGlvbiByZWFkU2luZ2xlRmlsZShmaWxlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZWFkQW5kR2V0RmlsZUhhc2goZmlsZSwgZmlsZS5lbmRzV2l0aCgnLmpzJykgJiYgIWZpbGUuZW5kc1dpdGgoJy50ZXN0LmpzJykpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZU5hbWUgPSBmaWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZUZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWUgPSBmaWxlRmlsdGVyKGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaWxlSGFzaGVzW2ZpbGVOYW1lXSA9IHJlc3VsdC5oYXNoO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmNvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlQ29udGVudHNbZmlsZU5hbWVdID0gcmVzdWx0LmNvbnRlbnRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICAgIHByb21pc2VzLnB1c2gocmVhZFNpbmdsZUZpbGUoZmlsZSkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGZpbGVzLCBmaWxlQ29udGVudHMsIGZpbGVIYXNoZXMgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogUmVhZHMgZmlsZXMgZnJvbSAuZGVza3RvcCBhbmQgY29tcHV0ZXMgYSB2ZXJzaW9uIGhhc2guXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRpciAtIHBhdGhcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbGVGaWx0ZXJcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkRmlsZXNBbmRDb21wdXRlSGFzaChkaXIsIGZpbGVGaWx0ZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBnZXRGaWxlTGlzdChkaXIsIHRydWUpXG4gICAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgICAgICAgLnRoZW4oZmlsZXMgPT4gcmVhZEFuZEhhc2hGaWxlcyhmaWxlcywgZmlsZUZpbHRlcikpXG4gICAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIHJlc3VsdC5oYXNoID0gY29tcHV0ZUhhc2hGb3JIYXNoZXNTZXQocmVzdWx0LmZpbGVzLCByZXN1bHQuZmlsZUhhc2hlcywgZmlsZUZpbHRlcik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogU3ltbGluayBleGlzdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoVG9DaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzeW1saW5rRXhpc3RzKHBhdGhUb0NoZWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZnMucmVhZGxpbmtTeW5jKHBhdGhUb0NoZWNrKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBnZXRGaWxlTGlzdCxcbiAgICBybVdpdGhSZXRyaWVzLFxuICAgIGV4aXN0cyxcbiAgICByZWFkRGlyLFxuICAgIHJlYWRBbmRHZXRGaWxlSGFzaCxcbiAgICBjb21wdXRlSGFzaEZvckhhc2hlc1NldCxcbiAgICByZWFkQW5kSGFzaEZpbGVzLFxuICAgIHJlYWRGaWxlc0FuZENvbXB1dGVIYXNoLFxuICAgIHN5bWxpbmtFeGlzdHNcbn07XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUpBOztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTQSxNQUFULENBQWdCQyxXQUFoQixFQUE2QjtFQUNoQyxJQUFJO0lBQ0FDLFdBQUEsQ0FBR0MsVUFBSCxDQUFjRixXQUFkOztJQUNBLE9BQU8sSUFBUDtFQUNILENBSEQsQ0FHRSxPQUFPRyxDQUFQLEVBQVU7SUFDUixPQUFPLEtBQVA7RUFDSDtBQUNKO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUNPLFNBQVNDLGFBQVQsQ0FBdUIsR0FBR0MsSUFBMUIsRUFBZ0M7RUFDbkMsSUFBSUMsT0FBTyxHQUFHLENBQWQ7RUFDQSxPQUFPLElBQUlDLE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7SUFDcEMsU0FBU0MsRUFBVCxDQUFZLEdBQUdDLE1BQWYsRUFBdUI7TUFDbkIsSUFBSTtRQUNBQyxnQkFBQSxDQUFNQyxNQUFOLENBQWFDLEtBQWIsR0FBcUIsSUFBckI7O1FBQ0FGLGdCQUFBLENBQU1GLEVBQU4sQ0FBUyxHQUFHQyxNQUFaOztRQUNBQyxnQkFBQSxDQUFNQyxNQUFOLENBQWFFLEtBQWI7O1FBQ0FQLE9BQU87TUFDVixDQUxELENBS0UsT0FBT0wsQ0FBUCxFQUFVO1FBQ1JHLE9BQU8sSUFBSSxDQUFYOztRQUNBLElBQUlBLE9BQU8sR0FBRyxDQUFkLEVBQWlCO1VBQ2JVLFVBQVUsQ0FBQyxNQUFNO1lBQ2JOLEVBQUUsQ0FBQyxHQUFHQyxNQUFKLENBQUY7VUFDSCxDQUZTLEVBRVAsR0FGTyxDQUFWO1FBR0gsQ0FKRCxNQUlPO1VBQ0hDLGdCQUFBLENBQU1DLE1BQU4sQ0FBYUUsS0FBYjs7VUFDQU4sTUFBTSxDQUFDTixDQUFELENBQU47UUFDSDtNQUNKO0lBQ0o7O0lBQ0RPLEVBQUUsQ0FBQyxHQUFHTCxJQUFKLENBQUY7RUFDSCxDQXBCTSxDQUFQO0FBcUJIOztBQUVNLFNBQVNZLE9BQVQsQ0FBaUJDLEdBQWpCLEVBQXNCQyxRQUF0QixFQUFnQztFQUNuQyxJQUFJLENBQUNBLFFBQUwsRUFBZTtJQUNYLE9BQU8sSUFBSVosT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtNQUNwQ1EsT0FBTyxDQUFDQyxHQUFELEVBQU0sQ0FBQ0UsR0FBRCxFQUFNQyxJQUFOLEVBQVlDLEtBQVosS0FBc0I7UUFDL0IsSUFBSUYsR0FBSixFQUFTO1VBQ0xYLE1BQU0sQ0FBQ1csR0FBRCxDQUFOO1FBQ0gsQ0FGRCxNQUVPO1VBQ0haLE9BQU8sQ0FBQztZQUFFYSxJQUFGO1lBQVFDO1VBQVIsQ0FBRCxDQUFQO1FBQ0g7TUFDSixDQU5NLENBQVA7SUFPSCxDQVJNLENBQVA7RUFTSDs7RUFDRCxJQUFJQyxJQUFJLEdBQUcsRUFBWDtFQUNBLElBQUlDLFFBQVEsR0FBRyxFQUFmOztFQUVBdkIsV0FBQSxDQUFHd0IsT0FBSCxDQUFXUCxHQUFYLEVBQWdCLENBQUNFLEdBQUQsRUFBTU0sS0FBTixLQUFnQjtJQUM1QixJQUFJTixHQUFKLEVBQVM7TUFDTCxPQUFPRCxRQUFRLENBQUNDLEdBQUQsQ0FBZjtJQUNIOztJQUNELElBQUlPLE9BQU8sR0FBR0QsS0FBSyxDQUFDRSxNQUFwQjs7SUFDQSxJQUFJLENBQUNELE9BQUwsRUFBYztNQUNWLE9BQU9SLFFBQVEsQ0FBQyxJQUFELEVBQU9JLElBQVAsRUFBYUMsUUFBYixDQUFmO0lBQ0g7O0lBQ0RFLEtBQUssQ0FBQ0csT0FBTixDQUFlQyxJQUFELElBQVU7TUFDcEIsTUFBTUMsUUFBUSxHQUFHQyxhQUFBLENBQUtDLElBQUwsQ0FBVWYsR0FBVixFQUFlWSxJQUFmLENBQWpCOztNQUNBN0IsV0FBQSxDQUFHaUMsSUFBSCxDQUFRSCxRQUFSLEVBQWtCLENBQUNJLElBQUQsRUFBT2IsS0FBUCxLQUFpQjtRQUMvQixJQUFJYSxJQUFKLEVBQVU7VUFDTixPQUFPaEIsUUFBUSxDQUFDZ0IsSUFBRCxDQUFmO1FBQ0g7O1FBQ0QsSUFBSWIsS0FBSyxDQUFDYyxXQUFOLEVBQUosRUFBeUI7VUFDckJuQixPQUFPLENBQUNjLFFBQUQsRUFBVyxDQUFDTSxLQUFELEVBQVFDLEdBQVIsRUFBYUMsU0FBYixLQUEyQjtZQUN6QyxJQUFJRixLQUFKLEVBQVc7Y0FDUCxPQUFPbEIsUUFBUSxDQUFDa0IsS0FBRCxDQUFmO1lBQ0g7O1lBQ0RkLElBQUksR0FBR0EsSUFBSSxDQUFDaUIsTUFBTCxDQUFZRixHQUFaLENBQVA7WUFDQWQsUUFBUSxHQUFHaUIsTUFBTSxDQUFDQyxNQUFQLENBQWNsQixRQUFkLEVBQXdCZSxTQUF4QixDQUFYO1lBQ0FaLE9BQU8sSUFBSSxDQUFYOztZQUNBLElBQUksQ0FBQ0EsT0FBTCxFQUFjO2NBQ1YsT0FBT1IsUUFBUSxDQUFDLElBQUQsRUFBT0ksSUFBUCxFQUFhQyxRQUFiLENBQWY7WUFDSDtVQUNKLENBVk0sQ0FBUDtRQVdILENBWkQsTUFZTztVQUNIRCxJQUFJLENBQUNvQixJQUFMLENBQVVaLFFBQVY7VUFDQVAsUUFBUSxDQUFDTyxRQUFELENBQVIsR0FBcUI7WUFDakJhLElBQUksRUFBRXRCLEtBQUssQ0FBQ3NCLElBREs7WUFFakJDLEtBQUssRUFBRSxDQUNIdkIsS0FBSyxDQUFDd0IsU0FBTixDQUFnQkMsT0FBaEIsRUFERyxFQUVIekIsS0FBSyxDQUFDMEIsS0FBTixDQUFZRCxPQUFaLEVBRkcsRUFHSHpCLEtBQUssQ0FBQzJCLEtBQU4sQ0FBWUYsT0FBWixFQUhHO1VBRlUsQ0FBckI7VUFRQXBCLE9BQU8sSUFBSSxDQUFYOztVQUNBLElBQUksQ0FBQ0EsT0FBTCxFQUFjO1lBQ1YsT0FBT1IsUUFBUSxDQUFDLElBQUQsRUFBT0ksSUFBUCxFQUFhQyxRQUFiLENBQWY7VUFDSDtRQUNKO01BQ0osQ0EvQkQ7SUFnQ0gsQ0FsQ0Q7RUFtQ0gsQ0EzQ0Q7QUE0Q0g7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNPLFNBQVMwQixXQUFULENBQXFCaEMsR0FBckIsRUFBMEJpQyxJQUFJLEdBQUcsS0FBakMsRUFBd0M7RUFDM0MsT0FBTyxJQUFJNUMsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtJQUNwQ1EsT0FBTyxDQUFDQyxHQUFELEVBQU0sQ0FBQ2tDLEtBQUQsRUFBUTFCLEtBQVIsS0FBa0I7TUFDM0IsSUFBSTBCLEtBQUosRUFBVztRQUNQM0MsTUFBTSxDQUFDMkMsS0FBRCxDQUFOO1FBQ0E7TUFDSCxDQUowQixDQUszQjs7O01BQ0EsSUFBSUMsa0JBQUo7O01BRUEsSUFBSUYsSUFBSixFQUFVO1FBQ04sTUFBTUcsV0FBVyxHQUFJcEMsR0FBRyxDQUFDcUMsTUFBSixDQUFXLENBQVgsRUFBYyxDQUFkLE1BQXFCLElBQXRCLEdBQThCckMsR0FBRyxDQUFDVSxNQUFKLEdBQWEsQ0FBM0MsR0FBK0NWLEdBQUcsQ0FBQ1UsTUFBSixHQUFhLENBQWhGO1FBQ0EsSUFBSTRCLFlBQVksR0FBRzlCLEtBQUssQ0FBQytCLEdBQU4sQ0FBV0MsR0FBRyxJQUFJQSxHQUFHLENBQUNILE1BQUosQ0FBV0QsV0FBWCxFQUF3QkssT0FBeEIsQ0FBZ0MsU0FBaEMsRUFBMkMsR0FBM0MsQ0FBbEIsQ0FBbkI7UUFDQSxNQUFNQyxjQUFjLEdBQUcsRUFBdkI7UUFDQWxDLEtBQUssQ0FBQ0csT0FBTixDQUFjLENBQUNDLElBQUQsRUFBTytCLENBQVAsS0FBYTtVQUN2QkQsY0FBYyxDQUFDSixZQUFZLENBQUNLLENBQUQsQ0FBYixDQUFkLEdBQWtDL0IsSUFBbEM7UUFDSCxDQUZEO1FBR0EwQixZQUFZLEdBQUdBLFlBQVksQ0FBQ0wsSUFBYixFQUFmO1FBQ0EsTUFBTVcsV0FBVyxHQUFHLEVBQXBCO1FBQ0FOLFlBQVksQ0FBQzNCLE9BQWIsQ0FBc0JrQyxHQUFELElBQVM7VUFDMUJELFdBQVcsQ0FBQ25CLElBQVosQ0FBaUJpQixjQUFjLENBQUNHLEdBQUQsQ0FBL0I7UUFDSCxDQUZEO1FBR0FWLGtCQUFrQixHQUFHUyxXQUFyQjtNQUNILENBYkQsTUFhTztRQUNIVCxrQkFBa0IsR0FBRzNCLEtBQXJCO01BQ0g7O01BQ0RsQixPQUFPLENBQUM2QyxrQkFBRCxDQUFQO0lBQ0gsQ0F6Qk0sQ0FBUDtFQTBCSCxDQTNCTSxDQUFQO0FBNEJIO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTVyxrQkFBVCxDQUE0QmxDLElBQTVCLEVBQWtDbUMsa0JBQWtCLEdBQUcsS0FBdkQsRUFBOEQ7RUFDakUsT0FBTyxJQUFJMUQsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtJQUNwQ1IsV0FBQSxDQUFHaUUsUUFBSCxDQUFZcEMsSUFBWixFQUFrQixDQUFDVixHQUFELEVBQU1DLElBQU4sS0FBZTtNQUM3QixJQUFJRCxHQUFKLEVBQVM7UUFDTFgsTUFBTSxDQUFDVyxHQUFELENBQU47UUFDQTtNQUNIOztNQUNELE1BQU0rQyxJQUFJLEdBQUdDLGVBQUEsQ0FBT0MsVUFBUCxDQUFrQixNQUFsQixDQUFiOztNQUNBRixJQUFJLENBQUNHLE1BQUwsQ0FBWWpELElBQVo7TUFDQSxNQUFNa0QsWUFBWSxHQUFHO1FBQUVKLElBQUksRUFBRUEsSUFBSSxDQUFDSyxNQUFMLENBQVksS0FBWjtNQUFSLENBQXJCOztNQUNBLElBQUlQLGtCQUFKLEVBQXdCO1FBQ3BCTSxZQUFZLENBQUNFLFFBQWIsR0FBd0JwRCxJQUFJLENBQUNxRCxRQUFMLENBQWMsTUFBZCxDQUF4QjtNQUNIOztNQUNEbEUsT0FBTyxDQUFDK0QsWUFBRCxDQUFQO0lBQ0gsQ0FaRDtFQWFILENBZE0sQ0FBUDtBQWVIO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNPLFNBQVNJLHVCQUFULENBQWlDQyxXQUFqQyxFQUE4Q0MsT0FBOUMsRUFBdURDLFNBQVMsR0FBR2YsR0FBRyxJQUFJQSxHQUExRSxFQUErRTtFQUNsRixNQUFNSSxJQUFJLEdBQUdDLGVBQUEsQ0FBT0MsVUFBUCxDQUFrQixNQUFsQixDQUFiOztFQUNBLE1BQU1VLFlBQVksR0FBR0gsV0FBVyxDQUFDSSxNQUFaLEVBQ2pCO0VBQ0EsQ0FBQ0MsT0FBRCxFQUFVbEIsR0FBVixNQUFtQmtCLE9BQU8sSUFBSUosT0FBTyxDQUFDQyxTQUFTLENBQUNmLEdBQUQsQ0FBVixDQUFsQixFQUFvQ2tCLE9BQXZELENBRmlCLEVBRWdELEVBRmhELENBQXJCO0VBSUFkLElBQUksQ0FBQ0csTUFBTCxDQUFZUyxZQUFaO0VBQ0EsT0FBT1osSUFBSSxDQUFDSyxNQUFMLENBQVksS0FBWixDQUFQO0FBQ0g7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTVSxnQkFBVCxDQUEwQnhELEtBQTFCLEVBQWlDeUQsVUFBakMsRUFBNkM7RUFDaEQsTUFBTUMsVUFBVSxHQUFHLEVBQW5CO0VBQ0EsTUFBTUMsWUFBWSxHQUFHLEVBQXJCO0VBQ0EsTUFBTUMsUUFBUSxHQUFHLEVBQWpCOztFQUVBLFNBQVNDLGNBQVQsQ0FBd0J6RCxJQUF4QixFQUE4QjtJQUMxQixPQUFPLElBQUl2QixPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO01BQ3BDdUQsa0JBQWtCLENBQUNsQyxJQUFELEVBQU9BLElBQUksQ0FBQzBELFFBQUwsQ0FBYyxLQUFkLEtBQXdCLENBQUMxRCxJQUFJLENBQUMwRCxRQUFMLENBQWMsVUFBZCxDQUFoQyxDQUFsQixDQUNLQyxJQURMLENBQ1dDLE1BQUQsSUFBWTtRQUNkLElBQUlDLFFBQVEsR0FBRzdELElBQWY7O1FBQ0EsSUFBSXFELFVBQUosRUFBZ0I7VUFDWlEsUUFBUSxHQUFHUixVQUFVLENBQUNRLFFBQUQsQ0FBckI7UUFDSDs7UUFDRFAsVUFBVSxDQUFDTyxRQUFELENBQVYsR0FBdUJELE1BQU0sQ0FBQ3ZCLElBQTlCOztRQUNBLElBQUl1QixNQUFNLENBQUNqQixRQUFYLEVBQXFCO1VBQ2pCWSxZQUFZLENBQUNNLFFBQUQsQ0FBWixHQUF5QkQsTUFBTSxDQUFDakIsUUFBaEM7UUFDSDs7UUFDRGpFLE9BQU87TUFDVixDQVhMLEVBWUtvRixLQVpMLENBWVduRixNQVpYO0lBYUgsQ0FkTSxDQUFQO0VBZUg7O0VBRURpQixLQUFLLENBQUNHLE9BQU4sQ0FBZUMsSUFBRCxJQUFVO0lBQ3BCd0QsUUFBUSxDQUFDM0MsSUFBVCxDQUFjNEMsY0FBYyxDQUFDekQsSUFBRCxDQUE1QjtFQUNILENBRkQ7RUFJQSxPQUFPLElBQUl2QixPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0lBQ3BDRixPQUFPLENBQUNzRixHQUFSLENBQVlQLFFBQVosRUFDS0csSUFETCxDQUNVLE1BQU07TUFDUmpGLE9BQU8sQ0FBQztRQUFFa0IsS0FBRjtRQUFTMkQsWUFBVDtRQUF1QkQ7TUFBdkIsQ0FBRCxDQUFQO0lBQ0gsQ0FITCxFQUlLUSxLQUpMLENBSVduRixNQUpYO0VBS0gsQ0FOTSxDQUFQO0FBT0g7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sU0FBU3FGLHVCQUFULENBQWlDNUUsR0FBakMsRUFBc0NpRSxVQUF0QyxFQUFrRDtFQUNyRCxPQUFPLElBQUk1RSxPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0lBQ3BDeUMsV0FBVyxDQUFDaEMsR0FBRCxFQUFNLElBQU4sQ0FBWCxDQUNLMEUsS0FETCxDQUNXbkYsTUFEWCxFQUVLZ0YsSUFGTCxDQUVVL0QsS0FBSyxJQUFJd0QsZ0JBQWdCLENBQUN4RCxLQUFELEVBQVF5RCxVQUFSLENBRm5DLEVBR0tTLEtBSEwsQ0FHV25GLE1BSFgsRUFJS2dGLElBSkwsQ0FJV0MsTUFBRCxJQUFZO01BQ2Q7TUFDQUEsTUFBTSxDQUFDdkIsSUFBUCxHQUFjUSx1QkFBdUIsQ0FBQ2UsTUFBTSxDQUFDaEUsS0FBUixFQUFlZ0UsTUFBTSxDQUFDTixVQUF0QixFQUFrQ0QsVUFBbEMsQ0FBckM7TUFDQTNFLE9BQU8sQ0FBQ2tGLE1BQUQsQ0FBUDtJQUNILENBUkw7RUFTSCxDQVZNLENBQVA7QUFXSDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNPLFNBQVNLLGFBQVQsQ0FBdUIvRixXQUF2QixFQUFvQztFQUN2QyxJQUFJO0lBQ0FDLFdBQUEsQ0FBRytGLFlBQUgsQ0FBZ0JoRyxXQUFoQjs7SUFDQSxPQUFPLElBQVA7RUFDSCxDQUhELENBR0UsT0FBT0csQ0FBUCxFQUFVO0lBQ1IsT0FBTyxLQUFQO0VBQ0g7QUFDSjs7ZUFHYztFQUNYK0MsV0FEVztFQUVYOUMsYUFGVztFQUdYTCxNQUhXO0VBSVhrQixPQUpXO0VBS1grQyxrQkFMVztFQU1YVyx1QkFOVztFQU9YTyxnQkFQVztFQVFYWSx1QkFSVztFQVNYQztBQVRXLEMifQ==